{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-04-21T07:40:09.000Z","updated":"2019-05-23T03:54:34.030Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"本人比较懒，什么都没有"},{"title":"","date":"2019-04-21T05:49:53.056Z","updated":"2019-04-21T05:49:53.056Z","comments":true,"path":"photo/index.html","permalink":"http://yoursite.com/photo/index.html","excerpt":"","text":"layout: phototitle: 相册date: 2017-02-08 09:40:04 type: “photo”"}],"posts":[{"title":"node接口","slug":"node","date":"2019-05-12T16:00:00.000Z","updated":"2019-06-03T14:40:35.717Z","comments":true,"path":"2019/05/13/node/","link":"","permalink":"http://yoursite.com/2019/05/13/node/","excerpt":"","text":"启动建一个文件夹npm initnpm i express框架 npm i nodemon方便好启动在建一个入口文件123456789const express = require('express')const app = express()app.get('/',(req,res)=&gt;&#123; res.send('holle word!')&#125;)const port = process.env.PORT || 5000app.listen(port, ()=&gt;&#123; console.log(`this $&#123;port&#125;`)&#125;) 然后在进入package.json修改1234\"scripts\": &#123; \"strat\": \"node server.js\", \"server\":\"nodemon server.js\" &#125;, 就可以npm run server启动 连接mongodbnpm i mongoose1const mongoose = require('mongoose') 建个文件夹123module.exports = &#123; mongoURI:\"mongodb+srv://web-Arui:mima@cluster0-cssww.azure.mongodb.net/test?retryWrites=true&amp;w=majority\"&#125; 引入1234567const db = require(\"./config/keys.js\").mongoURImongoose.connect(db) .then(()=&gt;console.log('res')) .catch(err=&gt;console.log(err))app.get('/',(req,res)=&gt;&#123; res.send('holle word!')&#125;)","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[]},{"title":"es6","slug":"es6","date":"2019-05-11T16:00:00.000Z","updated":"2019-06-06T09:58:09.797Z","comments":true,"path":"2019/05/12/es6/","link":"","permalink":"http://yoursite.com/2019/05/12/es6/","excerpt":"","text":"let const123456&#123; //块级作用域 let a=1 const b=1 //里面可以访问，外面不能访问&#125; let注意：1.没有域解析，不存在变量提升 在代码快内，只要let定义变量,在之前使用，都是报错 先定义，在使用2.同一个作用域里，不能重复定义变量3.for循环，for循环里面是父级作用域，里面又一个块级作用域 const注意：const特性和let一样const定义完变量，必须有值，不能后赋值，不能修改Object,freeze(对象)锁定这个对象，不能进行增加减少 结构赋值非常有用，特别在做交互ajax let[a,b,c] = [2,3,4]注意，左右两边，结构格式保持一致123456789let json =&#123; name:'11', age:'ee', ttt:'sss' &#125; let &#123;name,age,ttt&#125; = json console.log(name,age,ttt) let &#123;name:a,age:b,ttt:c&#125; = json console.log(a,b,c) //这样也是一样的 字符串模板优点：可以随意换行使用：${变量名字}1234let name=11 let age=13 let src = `这个人叫$&#123;name&#125;,年龄$&#123;age&#125;` console.log(src) 关于字符串一些东西字符串查找： str.indexOf(要找的东西) 返回索引（位置） 没有找到返回-1 str.includes(要找的东西) 返回值 true/fales 可以用来判断浏览器 ：includes 字符串是否以谁开头 列如:http://www.xx.xx str.startsWith(检测东西) 字符串是否以谁结尾 例如：.png str.endsWidh(检测东西) 重复字符串 str.repeat(重复的次数) 填充字符串 str.padStart(填充过后字符串长度,往前填充的东西) str.padEnd(填充过后字符串长度, 往后填充的东西)","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[]},{"title":"vue基础","slug":"vue","date":"2019-05-11T16:00:00.000Z","updated":"2019-05-29T15:07:08.769Z","comments":true,"path":"2019/05/12/vue/","link":"","permalink":"http://yoursite.com/2019/05/12/vue/","excerpt":"","text":"Vue关注视图层 mvvm v-的几种用法1234567891011121314151617181920212223242526272829303132333435363738394041424344//v-text innerText 用得比较少//v-html innerHtml//一般来说，v-if有更高的切换开销 v-show有更高的初始渲染开销new Vue(&#123; el: '#app', template:` &lt;div&gt; &lt;div v-html='msg'&gt;&lt;/div&gt; &lt;div v-if='isShow'&gt;&#123;&#123; msg2 &#125;&#125;&lt;/div&gt; &lt;div v-show='isShow'&gt;&lt;/div&gt; &lt;ul&gt; &lt;li v-for='(item,index) in list'&gt; &lt;h3&gt;&#123;&#123; index &#125;&#125;&lt;/h3&gt; &lt;h4&gt;&#123;&#123; item.id &#125;&#125;&lt;/h4&gt; &lt;h4&gt;&#123;&#123; item.name &#125;&#125;&lt;/h4&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for='(value,key) in Object'&gt; &#123;&#123; key &#125;&#125; -- &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, data()&#123; return &#123; msg: '&lt;h3&gt;我日&lt;/h3&gt;', msg2:'可以', isShow: true, list:[ &#123;id:1,name:'王昭君'&#125;, &#123;id:2,name:'李白'&#125;, &#123;id:3,name:'韩信'&#125; ], Object:&#123; name: '谭', age: '18', interesting: '游戏' &#125; &#125; &#125;,&#125;) v-bind绑定 的使用1234567891011121314151617181920212223242526272829303132&lt;style&gt; .po&#123; color: pink; &#125; .active &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app', template:` &lt;div&gt; &lt;div class='po' v-bind:class=\"&#123;active:isNo&#125;\"&gt;颜色&lt;/div&gt; &lt;button @click='changeColor'&gt;切换字体颜色&lt;/button&gt; &lt;/div&gt; `, data()&#123; return &#123; isNo:true &#125; &#125;, methods: &#123; changeColor()&#123; this.isNo = !this.isNo; &#125; &#125;, &#125;) &lt;/script&gt; v-model 的使用和原理123456789101112131415161718192021222324&lt;script&gt; //v-model只适用于有value属性的 new Vue(&#123; el: '#app', template:` &lt;div&gt; &lt;!--&lt;input type=\"text\" v-model='msg'&gt;--&gt; &lt;input type=\"text\" v-bind:value= \"msg\" v-on:input='change'&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt; `, data()&#123; return&#123; msg: '双向绑定' &#125; &#125;, methods: &#123; change(e)&#123; console.log(e.target.value) this.msg = e.target.value &#125; &#125;, &#125;) &lt;/script&gt; vue创建组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;div&gt; id=\"app\"&gt;&lt;/div&gt; &lt;script&gt; //声明全局组件 //第一个参数是组件名字，第二个是options Vue.component('vist',&#123; template:'&lt;button&gt;按钮&lt;/button&gt;', &#125;) // var vheader=&#123; template:\"&lt;div class='head'&gt;我是头部组件 &lt;vist/&gt;&lt;/div&gt;\" &#125; var side=&#123; template:\"&lt;div class='side'&gt;我是侧边栏 &lt;vist\\&gt;&lt;/div&gt;\" &#125; var vcontent=&#123; template:\"&lt;div class='content'&gt;我是内容区&lt;/div&gt;\" &#125; //声明局部组件 var App=&#123; template:` &lt;div class='main'&gt; &lt;vheader/&gt; &lt;side/&gt; &lt;vcontent/&gt; &lt;/div&gt; `, data()&#123; return &#123; &#125; &#125;, components:&#123; vheader, side, vcontent &#125; &#125; new Vue(&#123; el: '#app', template:'&lt;App&gt;&lt;/App&gt;', data() &#123; return &#123; &#125; &#125;, //挂载组件 components:&#123; App &#125; &#125;)&lt;/script&gt; 父组件给子组件传值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//1.在父组件中先绑定自定义属性='posts'//2.子要声明props:['自定义属性名']//3.子收到了就可以随便使用了Vue.component('vist',&#123; template:'&lt;button&gt;按钮&lt;/button&gt;',&#125;)//var vheader=&#123; template:\"&lt;div class='head'&gt;我是头部组件&lt;/div&gt;\"&#125;var side=&#123; template:\"&lt;div class='side'&gt;我是侧边栏&lt;/div&gt;\"&#125; var vcontent=&#123; template:` &lt;div&gt; &lt;ul&gt; &lt;li v-for='(item,index) in posts'&gt; &lt;h2&gt;&#123;&#123; index &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; item.title &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; item.content &#125;&#125;&lt;/h2&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, props:['posts']&#125;//声明局部组件var App=&#123; template:` &lt;div class='main'&gt; &lt;vheader/&gt; &lt;side/&gt; &lt;vcontent :posts='posts'/&gt; &lt;/div&gt; `, data()&#123; return &#123; posts:[ &#123;id:1,title:\"王昭君\",content:\"牛皮\"&#125;, &#123;id:2,title:\"李白\",content:\"牛皮\"&#125;, &#123;id:3,title:\"韩信\",content:\"可以\"&#125; ] &#125; &#125;, components:&#123; vheader, side, vcontent &#125;&#125;new Vue(&#123; el: '#app', template:'&lt;App&gt;&lt;/App&gt;', data() &#123; return &#123; &#125; &#125;, //挂载组件 components:&#123; App &#125;&#125;) 子传父12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Vue.component('vist',&#123; template:'&lt;button&gt;按钮&lt;/button&gt;', &#125;) // var vheader=&#123; template:` &lt;div class='head'&gt;我是头部组件 &lt;button @click='chageFontsize'&gt;字体变大&lt;/button&gt; &lt;/div&gt; `, methods: &#123; chageFontsize()&#123; this.$emit('chage') &#125; &#125;, &#125; var side=&#123; template:\"&lt;div class='side'&gt;我是侧边栏&lt;/div&gt;\" &#125; var vcontent=&#123; template:` &lt;div class='content'&gt; &lt;ul&gt; &lt;li v-for='(item,index) in posts'&gt; &lt;h2&gt;&#123;&#123; index &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; item.title &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; item.content &#125;&#125;&lt;/h2&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, props:['posts'] &#125; //声明局部组件 var App=&#123; template:` &lt;div class='main' :style= \"&#123;fontSize:postsSize+'em'&#125;\"&gt; &lt;vheader @chage='chageSize'/&gt; &lt;side/&gt; &lt;vcontent :posts='posts'/&gt; &lt;/div&gt; `, data()&#123; return &#123; posts:[ &#123;id:1,title:\"王昭君\",content:\"牛皮\"&#125;, &#123;id:2,title:\"李白\",content:\"牛皮\"&#125;, &#123;id:3,title:\"韩信\",content:\"可以\"&#125; ], postsSize:1 &#125; &#125;, methods: &#123; chageSize()&#123; this.postsSize+=0.1 &#125; &#125;, components:&#123; vheader, side, vcontent &#125; &#125; new Vue(&#123; el: '#app', template:'&lt;App&gt;&lt;/App&gt;', data() &#123; return &#123; &#125; &#125;, //挂载组件 components:&#123; App &#125; &#125;) slot元素作为承载分发内容的出口123Vue.component('vist',&#123; template:'&lt;button&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/button&gt;', &#125;) 过滤器在组件内部使用filters:{ 过滤器名字：function(value){ 内部一定要return}}12345678910111213141516171819202122232425var App=&#123; data() &#123; return &#123; price:0 &#125; &#125;, template:` &lt;div&gt; &lt;input type=\"number\" name=\"price\" v-model=\"price\"/&gt; &lt;h2&gt;&#123;&#123; price | myaa&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, filters:&#123; myaa:function(value)&#123; return '￥' + value &#125; &#125; &#125; new Vue(&#123; el: '#app', template:'&lt;App&gt;&lt;/App&gt;', components:&#123; App &#125; &#125;) 全局过滤器12345678910111213141516171819202122232425262728293031//全局过滤器 //function第二个为实参 Vue.filter('tan',function(value,arg1)&#123; return arg1+' '+value.split('').reverse().join('') &#125;) var App=&#123; data() &#123; return &#123; price:0, msg:'tan xing rui' &#125; &#125;, template:` &lt;div&gt; &lt;div&gt;&#123;&#123; price | myaa&#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; msg | tan('哈哈') &#125;&#125;&lt;/div&gt; &lt;/div&gt; `, filters:&#123; myaa:function(price)&#123; return '￥' + price &#125; &#125; &#125; new Vue(&#123; el: '#app', template:'&lt;App&gt;&lt;/App&gt;', components:&#123; App &#125; &#125;) watch监听数据123456&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model='msg'&gt; &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt; &lt;button @click=\"rui[0].name='rose'\"&gt;按钮&lt;/button&gt; &lt;div&gt;&#123;&#123; rui[0].name &#125;&#125;&lt;/div&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526new Vue(&#123; el: '#app', data() &#123; return &#123; msg:'', rui:[ &#123;name:'xxx'&#125; ] &#125; &#125;, watch: &#123; msg:function(newM,oldM)&#123; //console.log(newM,oldM) if(newM==='tan')&#123; console.log('出来了') &#125; &#125;, rui:&#123; //监听复杂数据类型 object array 深度监视 deep:true, handler:function(newM,oldM)&#123; console.log(newM[0].name) &#125; &#125; &#125;, &#125;) 生命周期12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var tan=&#123; data() &#123; return &#123; msg:'kk' &#125; &#125;, template:` &lt;div&gt; &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt; &lt;button @click='change'&gt;改变&lt;/button&gt; &lt;/div&gt; `, methods: &#123; change:function()&#123; this.msg=this.msg+'哈哈哈' &#125; &#125;, beforeCreate() &#123; //组件创建之前 console.log(this.msg) &#125;, created() &#123; //组件创建之后 //使用该组件就会调用这个created方法 //在created中可以操作后端的数据，数据相应试图 //应用:发起ajax请求 console.log(this.msg) this.msg='改变了' &#125;, beforeMount() &#123; //挂载数据之前到DOM之前会调用 console.log(document.getElementById('app')) &#125;, mounted() &#123; //挂载数据之前到DOM之后会调用 console.log(document.getElementById('app')) &#125;, beforeUpdate() &#123; //在更新DOM之前，调用此钩子函数，应用 可以获取原始的DOM console.log(document.getElementById('app').innerHTML) &#125;, updated() &#123; //在更新DOM之后，调用此钩子函数，应用 可以获取更新的DOM console.log(document.getElementById('app').innerHTML) &#125;, beforeDestroy() &#123; console.log(beforeDestroy) &#125;, destroyed() &#123; console.log(destroyed) &#125;, activated() &#123; console.log('组件被激活了') &#125;, deactivated() &#123; console.log('组件被停用了') &#125;, &#125; var app=&#123; data() &#123; return &#123; isShow:true &#125; &#125;, template:` &lt;div&gt; &lt;keep-alive&gt; &lt;tan v-if='isShow'&gt;&lt;/tan&gt; &lt;/keep-alive&gt; &lt;button @click='isShow = !isShow'&gt;改变生死&lt;/button&gt; &lt;/div&gt; `, components:&#123; tan &#125; &#125; new Vue(&#123; el: '#app', components:&#123; app &#125; &#125;) ref属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Vue.component('suba',&#123; template:` &lt;div&gt;000&lt;/div&gt; `, &#125;) var App=&#123; template:` &lt;div&gt; &lt;button ref='btn1'&gt;阿牛一&lt;/button&gt; &lt;button ref='btn2'&gt;阿牛一&lt;/button&gt; &lt;suba ref=sub&gt;&lt;/suba&gt; &lt;/div&gt; `, created() &#123; console.log(this.$refs.btn1) &#125;, beforeMount() &#123; console.log(this.$refs.btn1) &#125;, mounted() &#123; //如果是给标签绑定ref属性 使用this.$refs.xxx,获取的是原生js的DOM对象 //入股是给组件绑定ref属性 使用this.$refs.xxx,获取的是组件对象 console.log(this.$refs.btn1) console.log(this.$refs.btn2) console.log(this.$refs.sub) &#125;, &#125; new Vue(&#123; el:'#app', components:&#123; App &#125; &#125;)$nextTick的使用var App=&#123; data() &#123; return &#123; isShow:false &#125; &#125;, template:` &lt;div&gt; &lt;input type='text' v-show='isShow' ref='input'/&gt; &lt;/div&gt; `, created() &#123; &#125;, beforeMount() &#123; &#125;, mounted() &#123; this.isShow=true console.log(this.$refs.input) //$nextTick是在DOM更新循环结束之后执行延迟回调,在数据修改之后使用$nextTick, //可以在回调中获取更新后的DOM this.$nextTick(function()&#123; this.$refs.input.focus() &#125;) &#125;, &#125; new Vue(&#123; el:'#app', components:&#123; App &#125; &#125;) 路由的使用12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script&gt; //1让vue使用该VueRouter创建 Vue.use(VueRouter) //2声明组件 var login=&#123; template:'&lt;div&gt;我是登陆组件&lt;/div&gt;', &#125; var register=&#123; template:'&lt;div&gt;我是注册组件&lt;/div&gt;', &#125; //3创建路由对象 var router=new VueRouter(&#123; routes:[ &#123; path:'/login',component:login &#125;, &#123; path:'/register',component:register &#125; ] &#125;) //抛出两个全局组件router-link router-view var App=&#123; template:` &lt;div&gt; &lt;router-link to='/login'&gt;登陆&lt;/router-link&gt; &lt;router-link to='/register'&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `, &#125; //5将配置好的路由关联到vue实例化对象中 new Vue(&#123; el:'#app', router:router, template:'&lt;App&gt;&lt;/App&gt;', components:&#123; App &#125; &#125;) &lt;/script&gt; query params1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Vue.use(VueRouter) var useTan=&#123; template:'&lt;div&gt;我是用户1&lt;/div&gt;', created() &#123; console.log(this.$router) console.log(this.$route) &#125;, &#125; var useXing=&#123; template:'&lt;div&gt;我是用户二&lt;/div&gt;', created() &#123; &#125;, &#125; var router = new VueRouter(&#123; routes:[ &#123; //动态路由参数以冒号开头 path:'/use1/:id', name:'use1', component:useTan &#125;, &#123; path:'use2', name:'use2', component:useXing &#125; ] &#125;) //抛出了两个对象$router $route(路由信息对象) 挂载到vue实例化对象 var App=&#123; template:` &lt;div&gt; &lt;router-link :to=\"&#123;name:'use1',params:&#123;id:1&#125;&#125;\"&gt;用户1&lt;/router-link&gt; &lt;router-link :to=\"&#123;name:'use2',query:&#123;rui:2&#125;&#125;\"&gt;用户2&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `, &#125; new Vue(&#123; el:'#app', router, template:'&lt;App/&gt;', components:&#123; App &#125; &#125;) 路由的嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Vue.use(VueRouter) var useTan=&#123; template:'&lt;div&gt;我是用户1&lt;/div&gt;', &#125; var useXing=&#123; template:'&lt;div&gt;我是用户二&lt;/div&gt;', &#125; var home=&#123; template:` &lt;div&gt;首页 &lt;br/&gt; &lt;router-link to='/home/use1'&gt;用户1&lt;/router-link&gt; &lt;router-link to='/home/use2'&gt;用户2&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `, &#125; var router = new VueRouter(&#123; routes:[ &#123; path:'/home', name:'home', component:home, children:[ &#123; path:'/home/use1', component:useTan &#125;, &#123; path:'/home/use2', component:useXing &#125; ] &#125; ] &#125;) var App=&#123; template:` &lt;div&gt; &lt;router-link :to=\"&#123;name:'home'&#125;\"&gt;家&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `, &#125; new Vue(&#123; el:'#app', router, template:'&lt;App/&gt;', components:&#123; App &#125; &#125;) 路由守卫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;div id=\"app\"&gt; &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/blog\"&gt;我的博客&lt;/router-link&gt; &lt;router-link to=\"/login\"&gt;登陆&lt;/router-link&gt; &lt;a href=\"javascript:void(0);\" @click=\"clean\"&gt;退出&lt;/a&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; Vue.use(VueRouter) var home=&#123; template:` &lt;div&gt; 我是首页 &lt;/div&gt; `, &#125; var blog=&#123; template:` &lt;div&gt; 我的博客 &lt;/div&gt; `, &#125; var login=&#123; data() &#123; return &#123; name:' ', password:' ' &#125; &#125;, template:` &lt;div&gt; &lt;input type=\"text\" v-model=\"name\"&gt; &lt;input type=\"text\" v-model=\"password\"&gt; &lt;input type=\"button\" value=\"登陆\" @click=\"login\"&gt; &lt;/div&gt; `, methods: &#123; login()&#123; localStorage.setItem('user',&#123;name:this.name,password:this.password&#125;) //编程式导航 this.$router.push(&#123;name:'blog'&#125;) &#125; &#125;, &#125; var router=new VueRouter(&#123; routes:[ &#123; path:'/', redirect:'/home' &#125;, &#123; path:'/home', component:home &#125;, &#123; path:'/blog', name:'blog', component:blog, //给未来路由做权限控制，全局路由守卫 来做参照条件 meta:&#123; //表明用户访问该组件需要登陆 auth:true &#125; &#125;, &#123; path:'/login', component:login &#125; ] &#125;) router.beforeEach((to, from, next) =&gt; &#123; //console.log(to) //console.log(from) if(to.meta.auth)&#123; //用户点击博客,该用户未登录，需要登陆判断 准备跳转登陆页面 if(localStorage.getItem('user'))&#123; next() &#125;else&#123; next(&#123; path:'/login' &#125;) &#125; &#125;else&#123; next() //如果不调用next就会卡住 &#125; &#125;) new Vue(&#123; el:'#app', router, methods:&#123; clean()&#123; localStorage.removeItem('user') this.$router.push('/login') &#125; &#125; &#125;) &lt;/script&gt; keep-alive12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var tan =&#123; template:` &lt;div&gt;付费栏目&lt;/div&gt; `, created() &#123; console.log('created') &#125;, mounted() &#123; console.log('mounted') &#125;, destroyed()&#123; console.log('销毁了') &#125; &#125; var xing =&#123; template:` &lt;div&gt;测试栏目&lt;/div&gt; `, created() &#123; console.log('22created') &#125;, mounted() &#123; console.log('22mounted') &#125;, destroyed() &#123; console.log('22销毁了') &#125; &#125; Vue.use(VueRouter) var router = new VueRouter(&#123; routes:[ &#123; path:'/tan', component:tan &#125;, &#123; path:'/xing', component:xing &#125; ] &#125;) //keep-alive缓存 var App=&#123; template:` &lt;div&gt; &lt;router-link to=\"/tan\"&gt;付费&lt;/router-link&gt; &lt;router-link to=\"/xing\"&gt;测试&lt;/router-link&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt; `, &#125; new Vue(&#123; el:'#app', router, template:'&lt;App/&gt;', components:&#123; App &#125; &#125;) axios Get请求1234567891011121314151617181920212223var app = &#123; template:` &lt;button @click=\"getAxios\"&gt;get请求&lt;/button&gt; `, methods: &#123; getAxios()&#123; this.$axios.get('https://api.apiopen.top/getSongPoetry?page=1&amp;count=20').then(result=&gt;&#123; console.log(result) &#125;).catch(err=&gt;&#123; console.log(err) &#125;) &#125; &#125;, &#125; Vue.prototype.$axios=axios new Vue(&#123; el:'#app', template:'&lt;app/&gt;', components:&#123; app &#125; &#125;) 合并请求12345678910111213141516171819202122232425262728293031323334353637var app = &#123; data() &#123; return &#123; res1: '', res2: '' &#125; &#125;, template: ` &lt;div&gt; 相应1 : &#123;&#123; res1 &#125;&#125; 相应2 : &#123;&#123; res2 &#125;&#125; &lt;button @click=\"getAxios\"&gt;合并请求&lt;/button&gt; &lt;/div&gt; `, methods: &#123; getAxios() &#123; this.$axios.defaults.baseURL = 'https://api.apiopen.top/getSongPoetry?page=1&amp;count=20' var q1 = this.$axios.get('') var q2 = this.$axios.post('') this.$axios.all([q1, q2]).then(this.$axios.spread((res1, res2) =&gt; &#123; this.res1 = res1.data this.res2 = res2.data &#125;)) .catch(err =&gt; &#123; console.log(err) &#125;) &#125; &#125;, &#125; Vue.prototype.$axios = axios new Vue(&#123; el: '#app', template: '&lt;app/&gt;', components: &#123; app &#125; &#125;) 组件与组件之间的传值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id=\"app\"&gt; &lt;taa&gt;&lt;/taa&gt; &lt;tbb&gt;&lt;/tbb&gt;&lt;/div&gt;&lt;script&gt; var event = new Vue() var taa = &#123; data() &#123; return &#123; a:'我是a中的数据' &#125; &#125;, template: ` &lt;div&gt; &lt;div&gt;我是a:&#123;&#123; a &#125;&#125;&lt;/div&gt; &lt;button @click='send'&gt;传值&lt;/button&gt; &lt;/div&gt; `, methods: &#123; send() &#123; //$emit('事件名字',数据) event.$emit('taa',this.a) &#125; &#125;, &#125; var tbb = &#123; data() &#123; return &#123; a: '' &#125; &#125;, template: ` &lt;div&gt;接收a的值:&#123;&#123; a &#125;&#125;&lt;/div&gt; `, mounted() &#123; event.$on('taa',(a)=&gt;&#123; this.a=a &#125;) &#125;, &#125; new Vue(&#123; el: '#app', components: &#123; taa, tbb &#125; &#125;) &lt;/script&gt; 定义拦截器123456789101112131415161718//定义拦截器//1.请求发起前显示lodding open()Axios.interceptors.request.use(function(config)&#123; MintUi.Indicator.open(&#123; text:'玩命加载中...' spinnerType:'fading-circle' //config:&#123; headers &#125;&#125;) console.log(config) return config&#125;)//2相应回来后关闭 Loading close()Axios.interceptors.response.use(function(response)&#123; //response:&#123; config:&#123;&#125;,data:&#123;&#125;,headers&#125; //接收响应头或者响应体中的数据，保存起来，供请求的拦截器中使用头信息操作 MintUi.Indicator.close() console.log(response) return response&#125;) Vuex1234567891011121314 总结：this.$store.dispatch('方法') 去调用 //let store = new Vuex.Store(&#123;&#125;)//actions中有异步行为actions:&#123; 方法()&#125;去调用mutations:&#123;&#125;去更改state:&#123;&#125;从而改变试图当然getters:&#123; getNum(state)&#123; return state.什么 &#125;&#125;是获取数据的","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-04-20T15:29:28.584Z","updated":"2019-04-27T13:24:31.861Z","comments":true,"path":"2019/04/20/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/20/hello-world/","excerpt":"","text":"欢迎来到我的博客","categories":[],"tags":[]},{"title":"canvas 基础","slug":"canvas","date":"2019-02-18T16:00:00.000Z","updated":"2019-05-07T14:01:46.068Z","comments":true,"path":"2019/02/19/canvas/","link":"","permalink":"http://yoursite.com/2019/02/19/canvas/","excerpt":"","text":"基本的123先在body里面加上 &lt;canvas width='宽度' height='高度'&gt;&lt;/canvas&gt;注意:不能在样式里面设置canvas的宽高然后: 12345678var myCanvas = document.querySelector('canvas') //获取元素var ctx = myCanvas.getContext('2d') //获取上下文 绘制工具箱ctx.beginPath()//开启新路径ctx.moveTo(100,100) //移动画笔ctx.lineTo(200,100) //绘制直线 (轨迹，绘制路径)ctx.strokeStyle='red' //线条颜色ctx.lineWidth=30 //线条宽度ctx.stroke() // 描边 ctx.closePath()自动填充路径ctx.fillstyle=”red”填充颜色ctx.fill()填充 默认是黑色 看一块区域是否填充 从这快区域拉一条直线 看这条直线的相交轨迹 如果顺时针+1 如果逆时针-1 所有的轨迹的值计算出来 如果是非0就填充 如果是0就不填充 ctx.lineCap=”butt” 默认ctx.lineCap=”square’’ 两边加一个方形帽子ctx.lineCap=”round” 两边加一个园帽子ctx.lineJoin=”miter” 默认ctx.lineJoin=”bevel” 相交的拐点变成平的ctx.lineJoin=”round’’ 相交的拐点变成原的ctx.setLineDash([5,10,15]) 数组是用来描述你的排序方式（虚线）console.log(ctx.setLineDash())获取虚线的排列方式，获取的是不重复的那一段排序方式ctx.lineDashOffset=20 如果是正的值往后偏移，如果是负的值往前偏移 绘制矩形路径，不是独立路径ctx.rect(100,100,200,100)ctx.stroke() 绘制矩形路径，有自己的独立路径ctx,strokeRect(100,100,200,100) 描边矩形ctx.fillRect(100,100,200,100) 填充矩形 前两个点为坐标 然后是宽高 图形的左上方为坐标 清除矩形类容ctx.clearRect(0,0,200,100) 前两个点为坐标 然后是宽高 图形的左上方为坐标 颜色渐变var linearGradient=ctx.createLinearGradient(100,100,200,100) (前两个是起始点，后面是结束点)linearGradient.addColorStop(0,’pink’)linearGradient.addColorStop(0.5,’red’)linearGradient.addColorStop(1,’yellow’)ctx.fillStyle=linearGradient 圆的绘制1、2参数是圆心的位置3参数是半径4、5参数是起始幅度到结束幅度6参数是绘制的方向false是顺时针true是逆时针 默认是顺时针ctx.arc(0,0,150,Math.PI/2,Math.PI,false) 绘制文本var src =’’文字’’获取文字的宽度ctx.measureText(src).width注意：起点位置在文字的左下角（x0,y0）为起点位置ctx.strokeText(src ,x0,y0)ctx.fillText(src,x0,y0)填充字ctx.font=”40px 字体”左右对齐方式ctx.textAlign=”left” （left center right start end）基于起始坐标垂直对齐方式ctx.textBaseline=”middle’’(top middle bottom) 基于起始坐标对齐 图片的加载123456//图片的加载 var image = new Image() image.onload=function()&#123; console.log(image) &#125; image.src='images/code.jpg' 图片的绘制12345678910111213image.onload=function()&#123; //绘制图片的三种方式 //3参数的 //第一个参数图片对象，后面是坐标 ctx.drawImage(image,100,100) //5参数的 //第一个参数图片对象，2.3是坐标,4.5是图片大小，是缩放不是裁剪 ctx.drawImage(image,100,100,100,100) //9参数的 //第一个图片对象 2.3是图片上上的定位坐标。4.5是在图片上截取多大的区域 //6.7是绘制在画布上的坐标。8.9是图片的大小，是缩放不是裁剪 ctx,drawImage(image,100,100,200,200,111,111,222,222) &#125; 坐标变换translate(x,y) 平移，移动画布的原点，参数表示移动目标点的坐标scale(x,y)参数表示宽高的缩放比例rotate(Math.PI/6)参数表示旋转的角度","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[]},{"title":"css基础","slug":"css","date":"2019-02-17T16:00:00.000Z","updated":"2019-05-11T13:05:25.002Z","comments":true,"path":"2019/02/18/css/","link":"","permalink":"http://yoursite.com/2019/02/18/css/","excerpt":"","text":"CSS初识CSS(Cascading Style Sheets) 美化样式 CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。 CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。 css层叠样式的有####引入 行内样式 &lt;标签名 style=” ”&gt; 内链样式 一对style标签在head中 通过选择器13. 外链样式 &lt;link href=”css文件” /&gt; css文件不需要写style link标签：链入一个文档通过rel属性申明链入文档与当前文档之间的关系。 css文件中引入css文件@import url(“文件路径”); 选择器css基础选择器 标签选择器（元素选择器）标签名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 或者元素名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 类选择器 1xx&#123; 属性: 属性值 ; 属性: 属性值&#125; &lt;h3 class=”xx”&gt;&lt;/h3&gt; a. 多个class可以名一样的名b. 一个元素只能一个class属性c. 一个class可以取多个类名 class=”xx yy”d. 两个类名的样式有冲突 按css样式书写顺序 后面覆盖前面 Id选择器1xx&#123; 属性: 属性值 ; 属性: 属性值&#125; &lt;h3 id=”xx”&gt;&lt;/h3&gt; id名唯一 只能用一次 多类名选择器 我们可以给标签指定多个类名，从而达到更多的选择目的。1&lt;h3 class=\"a b c\"&gt;&lt;/h3&gt; 通配符选择器 通配符 选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。 { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 复合选择器 1234后代选择器 div p&#123; &#125; &lt;div&gt; &lt;p&gt;123&lt;/p&gt; &lt;/div&gt; div中的p 中间用空格隔开的都是后代选择子代选择器div p&gt;span&#123; &#125; &lt;div&gt; &lt;p&gt; &lt;span&gt;123&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; span是p的亲儿子交集选择器 div.cc &lt;div class=”cc”&gt;&lt;/div&gt; 即是div又是 .cc xx.one就是交集选择器并集选择器 div,span,p&#123; &#125; 用逗号隔开 集体声明 相同样式 伪类选择器 链接伪类选择器:link 未访问的链接:visited 已访问的链接:hover鼠标经过的链接 实际开发只用hover:active 鼠标按住链接 字体行高顶线 中线 基线 底线两行文字基线与基线之间的距离就是行高盒子高度等于 字体高度 上距离 下距离行高等于高度 垂直居中行高大于高度 偏下行高小于高度 偏上 font样式font-style normal正常 italic斜体 字体风格 i em配合font-weight bold==700加粗 normal==400 正常 数值没有单位 建议用数值 字体粗细 b strong 配合font-size 字体大小font-family:字体1 ,字体2 什么字体1多个字体执行从左开始2当没有才执行其他，都没有执行系统默认3中文或者有空格特殊字符的 用双引号连写 不能更换顺序h {font: font-style font-weight font-size/line-height font-family;} 注意字体大小不能省略 css外观样式color #红色 绿色 蓝色 red green blueline-height px em 行间距 行高等于盒子的高度 可以让单行文本垂直居中text-align 水平对齐 left right center 盒子内容对齐 （文字 行内元素 行内块元素）text-indent 2em 首行缩进 em一个字的距离注意以上都能继承text-decoration none无装饰 underline 下划线 line-through 贯穿线 u ins 配合 s del 配合 背景background-colorbackground-image：url(images/1.png ) background-repeat 属性值bepeat 背景纵横平铺no-repeat 背景不平铺repeat-x 背景横向平铺repeat-y 背景纵向平铺background –attachment 属性值 （一般做网页背景）fixed 背景图固定scroll 背景图滚动background-position: x y1后面可以跟方位名词 上下左右没有顺序2一个值 另一个值垂直居中3后面可以跟px值 12px 22px x y 连写 没有顺序要求 建议background：背景颜色 背景图片地址 背景平铺 背景滚动 背景位置background：rgba(0,0,0,0.5) 写法 0至1 背景透明度 圆角边框(css3)border-radius: 50%; 让正方形变成圆 等于宽高同样变圆border-radius: 1 2 3 4 1左上 2右上 3右下 4左下 顺时针border-radius:1 2 3 1左上 2右上 左下 3 右下border-radius:1 2 1 左上 右下 2右上 左下 对角线 盒子阴影box-shadow: 1px 2px 3px 4px rgba(0,0,0,0.4);1盒子水平影子 2盒子垂直影子 3模糊距离 4阴影大小5阴影颜色透明度 6内外阴影 清除所有内外边距1234*&#123; padding: 0; margin: 0;&#125; 取消li的前面小点1list-style: none; 块级元素123456789常见块级元素&lt;div&gt; &lt;p&gt; &lt;h1&gt;~&lt;h6&gt; &lt;form&gt; &lt;ul&gt; &lt;ol&gt; &lt;lI&gt; &lt;th&gt; &lt;table&gt;1单独占一行，其宽度自动填满父级元素宽度。高度是内容高度。2 margin和padding的上下左右都能设置3可以设置宽高注意1 &lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;只能嵌套行内元素2 &lt;hr&gt;不能嵌套其他元素3 &lt;ul&gt;&lt;ol&gt;&lt;dl&gt;的子元素只能是&lt;li&gt; &lt;dt&gt; &lt;dd&gt;4 &lt;table&gt;子元素必须是&lt;caption&gt;&lt; thead&gt;&lt; tbody&gt;&lt; tfoot&gt;,他们的子元素必须是&lt;tr&gt;元素,然后是&lt;th&gt; &lt;td&gt; 行内元素123456常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;、&lt;label&gt;、&lt;select&gt;、&lt;textarea&gt;1设置宽高无效 //可以设置行高2设置margin仅左右方向有效，padding左右有效，但会撑开盒子。3只能容纳行内元素和字体4不单独占一行，相邻行内元素排在同一行，排不下才换行，宽度高随元素内容变化。5 行内元素只能容纳文本或则其他行内元素。a特殊 a里面可以放块级元素 行内快元素12345678在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。行内块元素的特点：（1） 和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。用marging负边距可以解决。（2）默认宽度就是它本身内容的宽度。（3）高度，宽度，行高，margin以及padding都可以控制。（4）还可以设置垂直对齐属性 vertical-align 显示模式转换display: inline-blockinline 把块级元素转为行内元素block 把行内元素转为块级元素行内元素和行内块元素一般当成文本看","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[]},{"title":"html基础","slug":"html","date":"2018-06-17T16:00:00.000Z","updated":"2019-04-29T13:31:34.067Z","comments":true,"path":"2018/06/18/html/","link":"","permalink":"http://yoursite.com/2018/06/18/html/","excerpt":"","text":"html浏览器内核 Trident(IE内核) Gecko(Firefox内核) Presto(Opera前内核) (已废弃) Webkit(Safari内核,Chrome内核原型,开源) Blink（chrome）最新国产 web标准 结构 html 超文本标记语言 表现 css 层叠样式表 行为 java script 脚本语言 文档类型&lt;!DOCTYPE&gt;标签位于文档最前面，向浏览器说明当前文档使用HTML或XHTML标准规范，不然浏览器无法解析。 排版标签标题标签&lt;h1-h6&gt; h1一般用于logo段落标签 &lt;p&gt;水平标签 &lt;hr/&gt;换行标签&lt;br/&gt;单独一行&lt;div&gt;一行显示&lt;span&gt; 文本格式化标签1234&lt;b&gt; &lt;strong&gt; 加粗&lt;i&gt; &lt;em&gt; 斜&lt;s&gt; &lt;del&gt;删除&lt;u&gt; &lt;ins&gt; 下划线 的标签属性src 地址alt 图像不显示文本title 悬停内容border 图像边框厚度 属性href # 跳转地址target _blank 新窗口打开 _self 不用新窗口打开在head 中 整体用新窗口打开 锚点定位12&lt;a href=”#xx” titel=”悬浮显示的内容” alt=”不能显示图片显示的文字”&gt; //被点击在元素&lt;h1 id=”xx”&gt; //跳转至 特殊符号&amp;nbsp 空格&amp;lt &lt;符号&amp;gt &gt;符号 列表标签1231. 无序列表 &lt;ul&gt; &lt;li&gt; &lt;/li&gt; &lt;/ul&gt; 注意ul中不能放其他标签 li里面可以2. 有序列表 &lt;ol&gt; &lt;li&gt; &lt;/li&gt; &lt;/ol&gt;3. 自定义 &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt; 一个dt可以对应多个dd 多用于网页地部 表格table属性align 水平对齐方式 属性值center left right cellspacing单元格之间距离 cellpadding内容距离单元格边框距离 border 单元格边框 注意 一般三参为0，放在table标签中1234567&lt;caption&gt; &lt;/caption&gt; 表格标题 table中&lt;tr&gt; 行 &lt;td&gt;&lt;/td&gt; 列 可以容纳所有元素&lt;/tr&gt; &lt;th&gt; 表头替换td 效果居中加粗&lt;thead&gt;&lt;/thead&gt; 表头&lt;tbody&gt;&lt;/tbody&gt; 表体 合并单元格rowspan 跨行 注意1 先跨列 2先上后下 先左后右Colspan 跨列 input表单12345678910111213141516171819&lt;input /&gt; 属性type name 提交必须&lt;form&gt;&lt;/form&gt; 属性 注意表单必须有formaction 提交url地址 echo $SERVER[PHP_SELF] //提交本页method 提交方式 get url地址栏提交提交 postname 表单名size 控件宽度maxlenth 允许输入最多的字符数Type属性值text 文本域 password radio 单选 name=”sex”分组checkbox 复选name=”sex”分组button 普通按钮 value=”注册”submit 提交按钮value=”提交”reset 重置File 上传文件&lt;label for=\"xx\"&gt; &lt;input id=\"xx\"&gt;&lt;/label&gt; 包含input 点用户名直接进文本框 for在lable包含多个input 进入id定义的input文本框&lt;textarea&gt; &lt;/textarea&gt;文本域&lt;button&gt;&lt;/button&gt; //提交按钮 下拉菜单123&lt;section&gt; 默认选择 &lt;option value=\"\" selected=\"selected\"&gt;&lt;/option&gt; 默认选中 &lt;/section&gt;","categories":[{"name":"First","slug":"First","permalink":"http://yoursite.com/categories/First/"}],"tags":[]}]}